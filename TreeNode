import java.util.ArrayList;

/** class for individual BranchNodes in the codebreaking tree
  * @author William Turner
  * @version 1.3
 */
public class treeNode{
  
  // name of node
  String name;
  
  // the key contained at this node
  Key key;
  
  // the text being worked with
  String text;
  
  // processed text
  String keyedtext;
  
  // how correct the text processed with this node's key is
  double percentCorrect;
  
  // coder used
  Coder coder;
  
  // parent node
  treeNode parent;
  
  // array of tree BranchNodes
  ArrayList<treeNode> BranchNodes = new ArrayList<>();
  
  // the characters contained in words with one untranslated character left
  ArrayList<String> oneLeft = new ArrayList<>();
  
  // the characters contained in words with two untranslated characters left
  ArrayList<String> twoLeft = new ArrayList<>();
  
  int ran = 0;
  
  // Constructor for creating a node from scratch; sets parameter variables and calculates keyedtext and percentcorrect
  public treeNode(Key k, String t, String n, Coder c) {
    
    this.key = k;
    this.text = t;
    this.coder = c;
    this.name = n;
    
    this.keyedtext = coder.substitutionMethod(coder.regularalphabet, this.key, text);
    this.percentCorrect = coder.percentWords(keyedtext);
    this.capsList();
  }
  
  // Constructor for making a node as a child of node n, sets variables accordingly
  public treeNode(Key k, treeNode n, int i){
   
   this.parent = n;
   this.name = parent.getName() + "|" + i;
   this.key = k;
   this.text = parent.getText();
   this.coder = parent.coder;
   
   this.keyedtext = coder.substitutionMethod(coder.regularalphabet, this.key, text);
   this.percentCorrect = coder.percentWords(keyedtext);
   //this.capsList();
  }
  
  /** gets name of node
    * @return <code>name<code>
   */
  public String getName() {
    
   return name; 
  }
  
  /** sets name of node
    * @param String s the new name
   */
  public void setName(String s) {
    
    name = s;
  }
  
  /** gets the key of node
    * @return <code>key<code>
   */
  public Key getKey() {
    
   return key; 
  }

  /** gets text of node
    * @return <code>text<code>
   */
  public String getText() {
    
   return text; 
  }
    
  /** returns text processed with node's key
  * @return <code>keyedtext<code>
  */
  public String getKeyedText() {
    
   return keyedtext; 
  }
  
  /** gets parent node of calling node
    * @return <code>parent<code>
   */
  public treeNode getParent() {
    
   return parent; 
  }
  
  /** sets parent node
    * @param treeNode n the node to be set as the parent
   */
   public void setParent(treeNode n) {
    
    parent = n;
  }
  
   /** gets the percent correct variable
     * @return <code>percentCorrect<code>
    */
  public double getPercentCorrect() {
    
   return percentCorrect; 
  }
  
  /** shows all branchNodes of calling node. 
   */
  public void showNodes() {
    
    for(int i = 0; i < BranchNodes.size(); i++) {
      
     System.out.println(BranchNodes.get(i).getName());
     System.out.println(BranchNodes.get(i).getPercentCorrect());
     System.out.println(BranchNodes.get(i).getKey().toString());
     System.out.println("\n");
    }
  }
  
  /** adds a node to this node's branchNodes
    * @param treeNode n the node to be added
   */
  public void addNode(treeNode n) {
    
   BranchNodes.add(n); 
  }
  
  /** fills list of words in keyedtext that have one capital left and two capitals left
   */
  public void capsList() {
    
    //capital characters in current word being evaluated
    StringBuilder caps = new StringBuilder("");
    //number of caps in current word
    int numcaps = 0;
    
    /* runs through keyed text. Counts capital characters and adds to caps and numcaps.
     * upon reaching a space or the end of keyedtext, adds caps to oneLeft or twoLeft if appropriate 
     * and clears caps and numcaps
     */
    for(int i = 0; i < keyedtext.length(); i++) {
      
      // conditional branch for spaces and string end
      if (keyedtext.charAt(i) == ' ' || i == keyedtext.length() - 1)  {
       
        if(numcaps == 1) 
          if(!oneLeft.contains(caps.toString()))
         oneLeft.add(caps.toString());
        
       else if(numcaps == 2)
         twoLeft.add(caps.toString());
       
       caps.delete(0, caps.length() + 1);
       numcaps = 0;
      }
      
      // conditional branch for normal characters
      else {
       
        if(keyedtext.charAt(i) < 91 && keyedtext.charAt(i) > 64) {

         numcaps++;
         caps.append(keyedtext.charAt(i));
        }
      }
    }
    
    ArrayList<String> temp = new ArrayList<>();
    
    // a basic insertion sort for oneLeft
    for(int i = 0; i < oneLeft.size(); i++) {
      
      boolean added = false;
      if(temp.size() == 0)
        temp.add(oneLeft.get(i));
      
      else
     for(int j = 0; j < temp.size(); j++) {
       
       ran++;
   
       if(oneLeft.get(i).charAt(0) < temp.get(j).charAt(0) ) {
        
        temp.add(j, oneLeft.get(i));
        added = true;
        j = (temp.size());
        }
       
       if(!added)
         temp.add(oneLeft.get(i));
      } 
    }
    
    oneLeft = temp;
    //temp.clear();
  }
  
  /** fills branchNodes with most likely potential nodes.
   */
  public void makeNodes() {
    

  }
  /** insertion sort of all branchnodes
   */
  public void sortNodes() {
  
  } 
}
  
