/**
 * @author William Turner
 * Main class for EECS 393 cipher program project
 * @version 1.1 3/22/2019
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.ArrayIndexOutOfBoundsException;
import java.lang.NullPointerException;

public class Coder{
  
  StringBuilder[] table = new StringBuilder[26];
  Key regularalphabet = new Key("abcdefghijklmnopqrstuvwxyz");
  FileReader f;
  BufferedReader b;
  Trie t = new Trie();
  String str = new String("start");

 public Coder(){
   
   // double for loop to construct vigenere table
   for(int i = 0; i < 26; i++){
     table[i] = new StringBuilder("");
     for(int j = 0; j < 26; j++){
       
      table[i].append((char)(97 + ((i + j) % 26))); 
     }
   }
   
   // try/catch series to set up trie
   
   try {
      f = new FileReader("corncob_lowercase.txt");
      b = new BufferedReader(f);
      
      while ((str = b.readLine()) != null) {
            
       t.insert(str);
      }
    }
    
    catch (IOException e) {
      
      System.out.println("fail");
    }
    
    catch (ArrayIndexOutOfBoundsException a) {
      
      System.out.println(str);
    }
    
    catch (NullPointerException n){
      
      System.out.println(str);
    }
 }
 
 /** The process for the Caesar cipher
   * @param String s The string representing the text document
   * @param int shift The shift count to use with the Caesar Cipher
   * @return <code>this.substitutionMethod(key1, key2, text)<code> the processed text
  */ 
 public String caesarCipher(String s, int shift, boolean encode){
   
   Key key1 = new Key("");
   Key key2 = new Key("");
   
   if (encode) {
     
    key1.setString(table[0].toString());
    key2.setString(table[shift].toString());
   }
   
   else {
    
    key1.setString(table[shift].toString());
    key2.setString(table[0].toString());
   }  
   return this.substitutionMethod(key1, key2, s);
 }
 
 /** The process for the Vigenere cipher
   * @param String s the text to be worked with
   * @return <code>returnstring<code> the processed text
  */
  public String vigenereCipher(String s, Keyword keyword, boolean encode) {
 
    StringBuilder returnstring = new StringBuilder("");
    StringBuilder plaintext = new StringBuilder("");
    
    int p;
    
    for(int i = 0; i < s.length(); i++){
      
     if (s.charAt(i) != ' ')
       plaintext.append(s.charAt(i));
    }
   
     // for loop to build returnstring
     for(int i = 0; i < plaintext.length(); i++) {
      
         p = (i) % (keyword.length());   
       
       if(encode)
         returnstring.append(this.caesarCipher( Character.toString(plaintext.charAt(i)), 
                                             (Character.getNumericValue(keyword.charAt(p)) - 10), true ));
       else
         returnstring.append(this.caesarCipher( Character.toString(plaintext.charAt(i)), 
                                              (Character.getNumericValue(keyword.charAt(p)) - 10), false )); 
       
    }
    return returnstring.toString();
 }
 
 /** The method to perform the monoalphabetic substitution process
   * @param Key key1 the first half of the key
   * @param Key key2 the second half of the key
   * @param String temptext the text to be worked with
   * @return <code>returnstring.toString()<code> the processed text
  */ 
 public String substitutionMethod(Key key1, Key key2, String temptext) {
    
  StringBuilder returnstring = new StringBuilder();
    
    // double for loop to run through text and check character against key to append correct value to returnstring
    for(int i = 0; i < temptext.length(); i++) { 
      
       if (temptext.charAt(i) == (' '))
          returnstring.append(" ");
       else {
      
         for(int j = 0; j < key1.length(); j++) {
        
        if(temptext.charAt(i) == key1.charAt(j)) 
          returnstring.append(key2.charAt(j));
         }
      }
    }
    return returnstring.toString();
  }
 
 /** The method to count the frequency of characters in a string
   * @param String s the string to count the letters in
   * @return <code>frequencies<code> the int array counting the frequency of each character
  */ 
 public int[] countLetters(String s){
   
   String input = s;
   int[] frequencies = new int[26];
    
    // loop to run through string and index appropriate array value at each character 
    for(int i = 0; i < input.length(); i++) {
      
      frequencies[((int) s.charAt(i)) - 97]++; 
    }   
    return frequencies;
  }
 
 /** checks a string for repeats of characters
   * @param String s the plain text
   * @return <code>doesitrepeat<code> the boolean representing whether or not a string has repeat characters
  */ 
 public boolean checkForRepeats(String s){
   
   boolean doesitrepeat = false;
   String input = s;
   int[] frequencies = new int[26];
   
   // run through string and check for repeats
   for(int i = 0; i < input.length(); i++){
     
    if(frequencies[((int) s.charAt(i)) - 97] == 0)
      frequencies[((int) s.charAt(i)) - 97]++;
    else
      doesitrepeat = true;
   }
  return doesitrepeat; 
 }
 
 /** tells whether  or not a string is a word
   * @param String word the word to check
   * @return <code>t.search(word)<code>
  */ 
 public boolean isItAWord(String word) {     
   
        return t.search(word);
 }
 
 /** tells what percent words (by letter volume) a string is
   * @param String s
   * @return <code>((inWords / (inWords + notInWords)) * 100)<code>
  */ 
 public double percentWords(String s) {
   
   // amount of characters in real words
   double inWords = 0;
   // amount of characters not in real words
   double notInWords = 0;
   // number of spaces in the string
   double spaces = 0;
   // Stringbuilder that temporarily holds each word
   StringBuilder word = new StringBuilder("");
   
   /* runs through string, adds character to "word" until it reaches a space, then checks whether or not "word" is a 
    * word using a trie, then adds to the appropriate variable and resets "word"
    */ 
   for(int i = 0; i < s.length(); i++) {
     
     if (i == (s.length() - 1)) {
      
       word.append(s.charAt(i));
       
       if(t.search(word.toString())) 
         inWords = inWords + word.length();
       else 
         notInWords = notInWords + word.length();
     }
     
     if( (s.charAt(i) == (' ')) ) {
       
       if(t.search(word.toString())) 
         inWords = inWords + word.length();
       else 
         notInWords = notInWords + word.length();  

      word.delete(0, word.length() );
      spaces++;
     }
     
     else
       word.append(s.charAt(i));
       
   }
  return ((inWords / (inWords + notInWords)) * 100); 
 }
}
