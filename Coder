/**
 * @author William Turner
 * Main class for EECS 393 cipher program project
 * @version 1.4 4/09/2019
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.ArrayIndexOutOfBoundsException;
import java.lang.NullPointerException;
import java.util.Stack;

public class Coder{
  
  StringBuilder[] table = new StringBuilder[26];
  Key regularalphabet = new Key("abcdefghijklmnopqrstuvwxyz");
  FileReader f;
  BufferedReader b;
  Trie t = new Trie();
  String str = new String("start");
  int ran = 0;
  int rantwo = 0;
  int ranthree = 0;
  int ranfour = 0; 
  int ranfive = 0;
  int ransix = 0;

 public Coder(){
   
   // double for loop to construct vigenere table
   for(int i = 0; i < 26; i++){
     table[i] = new StringBuilder("");
     for(int j = 0; j < 26; j++){
       
      table[i].append((char)(97 + ((i + j) % 26))); 
     }
   }
   
   // try/catch series to set up trie
   
   try {
      f = new FileReader("corncob_lowercase.txt");
      b = new BufferedReader(f);
      
      while ((str = b.readLine()) != null) {
            
       t.insert(str);
      }
    }
    
    catch (IOException e) {
      
      System.out.println("fail");
    }
    
    catch (ArrayIndexOutOfBoundsException a) {
      
      System.out.println(str);
    }
    
    catch (NullPointerException n){
      
      System.out.println(str);
    }
 }
 
 /** The process for the Caesar cipher
   * @param String s The string representing the text document
   * @param int shift The shift count to use with the Caesar Cipher
   * @return <code>this.substitutionMethod(key1, key2, text)<code> the processed text
  */ 
 public String caesarCipher(String s, int shift, boolean encode){
   
   Key key1 = new Key("");
   Key key2 = new Key("");
   
   if (encode) {
     
    key1.setString(table[0].toString());
    key2.setString(table[shift].toString());
   }
   
   else {
    
    key1.setString(table[shift].toString());
    key2.setString(table[0].toString());
   }  
   return this.substitutionMethod(key1, key2, s);
 }
 
 /** The process for the Vigenere cipher
   * @param String s the text to be worked with
   * @return <code>returnstring<code> the processed text
  */
  public String vigenereCipher(String s, Keyword keyword, boolean encode) {
 
    StringBuilder returnstring = new StringBuilder("");
    StringBuilder plaintext = new StringBuilder("");
    
    int p;
    
    for(int i = 0; i < s.length(); i++){
      
     if (s.charAt(i) != ' ')
       plaintext.append(s.charAt(i));
    }
   
     // for loop to build returnstring
     for(int i = 0; i < plaintext.length(); i++) {
      
         p = (i) % (keyword.length());   
       
       if(encode)
         returnstring.append(this.caesarCipher( Character.toString(plaintext.charAt(i)), 
                                             (Character.getNumericValue(keyword.charAt(p)) - 10), true ));
       else
         returnstring.append(this.caesarCipher( Character.toString(plaintext.charAt(i)), 
                                              (Character.getNumericValue(keyword.charAt(p)) - 10), false )); 
       
    }
    return returnstring.toString();
 }
 
 /** The method to perform the monoalphabetic substitution process
   * @param Key key1 the first half of the key
   * @param Key key2 the second half of the key
   * @param String temptext the text to be worked with
   * @return <code>returnstring.toString()<code> the processed text
  */ 
 public String substitutionMethod(Key key1, Key key2, String temptext) {
    
  StringBuilder returnstring = new StringBuilder();
    
    // double for loop to run through text and check character against key to append correct value to returnstring
    for(int i = 0; i < temptext.length(); i++) { 
      
       if (temptext.charAt(i) == (' '))
          returnstring.append(" ");
       
       else 
         if (key2.charAt(key1.indexOf(temptext.charAt(i))) == '-')
            returnstring.append( (char)(temptext.charAt(i) - 32) );
         else
           returnstring.append(key2.charAt( key1.indexOf(temptext.charAt(i))) );
    
    }
    return returnstring.toString();
  }
 
 /** The method to count the frequency of characters in a string
   * @param String s the string to count the letters in
   * @return <code>frequencies<code> the int array counting the frequency of each character
  */ 
 public char[] countLetters(String s){
   
   String input = s;
   int[] frequencies = new int[26];
   
   char[] letters = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
    
    // loop to run through string and index appropriate array value at each character 
    for(int i = 0; i < input.length(); i++) {
      
      if(s.charAt(i) != ' ')
         frequencies[((int) s.charAt(i)) - 97]++; 
    }  
    
    for(int j = 1; j < 26; j++) {
      
      char temp = letters[j];
      int k = j-1;
      
      while(k >= 0 && (frequencies[letters[k] - 97] < frequencies[temp - 97])) {
        
        letters[k + 1] = letters[k];
        k = k - 1;
      }
      
      letters[k + 1] = temp;
    }
   
    return letters;
  }
 
 /** checks a string for repeats of characters
   * @param String s the plain text
   * @return <code>doesitrepeat<code> the boolean representing whether or not a string has repeat characters
  */ 
 public boolean checkForRepeats(String s){
   
   boolean doesitrepeat = false;
   String input = s;
   int[] frequencies = new int[26];
   
   // run through string and check for repeats
   for(int i = 0; i < input.length(); i++){
     
    if(frequencies[((int) s.charAt(i)) - 97] == 0)
      frequencies[((int) s.charAt(i)) - 97]++;
    else
      doesitrepeat = true;
   }
  return doesitrepeat; 
 }
 
 /** tells whether  or not a string is a word
   * @param String word the word to check
   * @return <code>t.search(word)<code>
  */ 
 public boolean isItAWord(String word) {     
   
        return t.search(word);
 }
 
 /** tells what percent words (by letter volume) a string is
   * @param String s
   * @return <code>((inWords / (inWords + notInWords)) * 100)<code>
  */ 
 public double percentWords(String s) {
   
   // amount of characters in real words
   double inWords = 0;
   // amount of characters not in real words
   double notInWords = 0;
   // number of spaces in the string
   double spaces = 0;
   // Stringbuilder that temporarily holds each word
   StringBuilder word = new StringBuilder("");
   
   /* runs through string, adds character to "word" until it reaches a space, then checks whether or not "word" is a 
    * word using a trie, then adds to the appropriate variable and resets "word"
    */ 
   for(int i = 0; i < s.length(); i++) {
     
     if (i == (s.length() - 1)) {
      
       word.append(s.charAt(i));
       
       if(t.search(word.toString())) 
         inWords = inWords + word.length();
       else 
         notInWords = notInWords + word.length();
     }
     
     if( (s.charAt(i) == (' ')) ) {
       
       if(t.search(word.toString())) 
         inWords = inWords + word.length();
       else 
         notInWords = notInWords + word.length();  

      word.delete(0, word.length() );
      spaces++;
     }
     
     else
       word.append(s.charAt(i));
       
   }
  return ((inWords / (inWords + notInWords)) * 100); 
 }
 
 /** Converts a string to lower case characters
   * @param String s the string to be converted
   * @return <code>returnstring.append(s.charAt(i))<code> the processed string
  */
 public String toLowerCase(String s) {
   
   StringBuilder returnstring = new StringBuilder("");
   
   for(int i = 0; i < s.length(); i++) {
     
     if( (64 < ((int)(s.charAt(i)))) && ( ((int)(s.charAt(i))) < 91  ) )
       returnstring.append( (char)(((int)s.charAt(i)) + 32) );
     
     else
       returnstring.append(s.charAt(i));
   }
   
   return returnstring.toString();
 }
 
 public String tryKey(Key key, String s) {
   
  return this.substitutionMethod(regularalphabet, key, s); 
 }
 
 public boolean timeTest(int i) {
   
  Key k = new Key("abcdefghijklmnopqrstuvwxyz"); 
  String s = new String("i am the very model of a modern major general" +  
                          "\n i have information vegetable animal and mineral" +
                          "\n i know the kings of england and i quote the" +
                          "\n fights historical from marathon to waterloo in order categorical" + 
                          "\n i am very well acquainted too with matters mathematical" + 
                          "\n i understand equations both the simple and quadratical" + 
                          "\n about binomial theorem i am teeming with a lot of news" + 
                          "\n with many cheerful facts about the square of the hypotenuse");
  String ss;
  
  for(int j = 0; j < i; j++) {
    
   ss = this.substitutionMethod(regularalphabet, k, s); 
  }
  
  return true;
 }
 
 public void findFirstWord(String s){
   
  // The array of initial keys to try 
  Key[] theobkeys = new Key[120];
  
  // array of tree nodes
  treeNode[] nodes = new treeNode[120];
  
  // The order of letters in s by frequency
  Character[] letterorder = new Character[26]; 
  
  // The possible characters to add to the key
  StringBuilder possibilities = new StringBuilder("");
  
  // Copy of possibilities
  StringBuilder possibilitiestemp = new StringBuilder("");

  // fills out letterorder to match countLetters
  for(int i = 0; i < 26; i++) {
    
   letterorder[i] = this.countLetters(s)[i]; 
  }
  
  // Makes array of five letters to attempt all decryptions for
  Character[] theob = new Character[5];
    theob[0] = 't';
    theob[1] = 'h';
    theob[2] = 'e';
    theob[3] = 'o';
    theob[4] = 'b';
    
  
  // Adds first five characters in letterOrder to possibilities and possibilitiestemp
  for(int i = 0; i < 5; i++) {

    possibilities.append(letterorder[i].toString());
    possibilitiestemp.append(letterorder[i].toString());
  }
  
  
  // Makes the 120 possible test keys with the five most common letters in the text
  StringBuilder w = new StringBuilder("--------------------------");
  
  for(int a = 0; a < 5; a++ ) {

    Character tempa = new Character(possibilities.charAt(a));
    w.replace(19, 20, tempa.toString());
    possibilities.delete(a, a + 1);
    
    for(int b = 0; b < 4; b++ ) {

      Character tempb = new Character(possibilities.charAt(b));
      w.replace(7,8, tempb.toString());
      possibilities.delete(b, b + 1);
      
      for(int c= 0; c < 3; c++ ) {

        Character tempc = new Character(possibilities.charAt(c));
        w.replace(4,5, tempc.toString());
        possibilities.delete(c, c + 1);
        
        for(int d = 0; d < 2; d++ ) {
          
          Character tempd = new Character(possibilities.charAt(d));
          w.replace(14,15, tempd.toString());
          possibilities.delete(d, d + 1);

          
          Character tempe = new Character(possibilities.charAt(0));
          w.replace(1,2, tempe.toString());
          
          ran++;
          theobkeys[ran - 1] = new Key(w.toString());
          
          possibilities.insert(d, tempd);
        }
        
        possibilities.insert(c, tempc);
      }
      
      possibilities.insert(b, tempb);
    } 
    
    possibilities.insert(a, tempa);
  }
   ran = 0;
   
   // makes new tree nodes with key battery
   for(int z = 0; z < 120; z++) {
     
     String name;
     name = "name" + (z);
     nodes[z] = new treeNode(theobkeys[z], s, name,this);
   }
   
   
   
  }
}

